# -*- coding: utf-8 -*-
import json
import re
import asyncio
import random
from telethon import events
from app.context import get_application
from .logic import trade_logic
from app.logger import format_and_log
from config import settings
from app.telegram_client import CommandTimeoutError

HELP_TEXT_PRIVATE_TRADE = """ğŸ” **ç§èŠäº¤æ˜“**
**è¯´æ˜**: åœ¨ç§èŠç¯å¢ƒä¸­ï¼Œç”±å½“å‰è´¦å·å‘èµ·ï¼Œä¸æŒ‡å®šåŠ©æ‰‹å®Œæˆä¸€æ¬¡å®‰å…¨çš„ç‰©å“è½¬ç§»ï¼ˆå¯¹æ–¹ä¸Šæ¶ï¼Œè‡ªå·±è´­ä¹°ï¼‰ã€‚
**ç”¨æ³•**: `,ç§èŠäº¤æ˜“ <@ç›®æ ‡åŠ©æ‰‹> <ç‰©å“> <æ•°é‡>`
**ç¤ºä¾‹**: `,ç§èŠäº¤æ˜“ @MyHelperBot å‡è¡€è‰ 10`
"""

HELP_TEXT_PRIVATE_FOCUS_FIRE = """ğŸ”¥ **ç§å¯†é›†ç«**
**è¯´æ˜**: ä¸â€œé›†ç«â€åŠŸèƒ½ç±»ä¼¼ï¼Œä½†æ•´ä¸ªä¸Šæ¶å’Œè´­ä¹°è¿‡ç¨‹éƒ½åœ¨ä¸æ¸¸æˆBotçš„ç§èŠä¸­è¿›è¡Œï¼Œå¹¶åœ¨ç»“æŸåè‡ªåŠ¨æ¸…ç†åŒæ–¹çš„ç§èŠè®°å½•ã€‚
**ç”¨æ³•**: `,ç§ç« <ç‰©å“> <æ•°é‡>`
**ç¤ºä¾‹**: `,ç§ç« å‡è¡€è‰ 10`
"""

# ç”¨äºåœ¨å†…å­˜ä¸­è¿½è¸ªå½“å‰ä»»åŠ¡çš„çŠ¶æ€
sessions = {}

async def _cmd_private_trade(event, parts):
    app = get_application()
    client = app.client
    my_id = str(client.me.id)
    my_username = client.me.username or my_id

    if len(parts) < 4:
        await client.reply_to_admin(event, f"âŒ å‚æ•°ä¸è¶³ï¼\n\n{HELP_TEXT_PRIVATE_TRADE}")
        return

    target_username = parts[1].lstrip('@')
    item_name = parts[2]
    try:
        quantity = int(parts[3])
    except ValueError:
        await client.reply_to_admin(event, f"âŒ æ•°é‡å¿…é¡»æ˜¯æ•°å­—ï¼")
        return
        
    if not getattr(settings, 'GAME_BOT_USERNAME', None):
        await client.reply_to_admin(event, "âŒ **é…ç½®ç¼ºå¤±**: è¯·åœ¨ `prod.yaml` ä¸­æ·»åŠ  `game_bot_username` é…ç½®é¡¹ã€‚")
        return

    progress_msg = await client.reply_to_admin(event, f"â³ `[{my_username}] ç§èŠäº¤æ˜“å¯åŠ¨`\næ­£åœ¨è§£æç›®æ ‡åŠ©æ‰‹...")
    client.pin_message(progress_msg)
    
    try:
        target_entity = await client.client.get_entity(target_username)
        executor_id = str(target_entity.id)
    except (ValueError, TypeError):
        await progress_msg.edit(f"âŒ **ç›®æ ‡æ— æ•ˆ**: æ— æ³•æ‰¾åˆ°ç”¨æˆ·`@{target_username}`ã€‚")
        client.unpin_message(progress_msg)
        return

    await progress_msg.edit(f"âœ… `å·²å®šä½åŠ©æ‰‹` (@{target_username})\nâ³ æ­£åœ¨é€šè¿‡ Redis ä¸‹è¾¾ä¸Šæ¶æŒ‡ä»¤...")
    
    session_id = f"ptrade_{my_id}_{int(asyncio.get_running_loop().time())}"
    sessions[session_id] = {"initiator_id": my_id, "executor_id": executor_id, "messages_to_delete": {"initiator": [], "executor": []}}

    task = {
        "task_type": "private_list_for_trade",
        "target_account_id": executor_id,
        "payload": { "session_id": session_id, "item_name": item_name, "item_quantity": quantity, "initiator_id": my_id }
    }
    await trade_logic.publish_task(task)
    await progress_msg.edit(f"âœ… `æŒ‡ä»¤å·²å‘é€`\næ­£åœ¨ç­‰å¾… @{target_username} åœ¨ç§èŠä¸­ä¸Šæ¶ç‰©å“...")
    client.unpin_message(progress_msg)

async def _cmd_private_focus_fire(event, parts):
    app = get_application()
    client = app.client
    my_id = str(client.me.id)
    my_username = client.me.username or my_id

    if len(parts) < 3:
        await client.reply_to_admin(event, f"âŒ å‚æ•°ä¸è¶³ï¼\n\n{HELP_TEXT_PRIVATE_FOCUS_FIRE}")
        return

    item_name = " ".join(parts[1:-1])
    try:
        quantity = int(parts[-1])
    except (ValueError, IndexError):
        await client.reply_to_admin(event, f"âŒ å‚æ•°æ ¼å¼é”™è¯¯ï¼")
        return
        
    if not getattr(settings, 'GAME_BOT_USERNAME', None):
        await client.reply_to_admin(event, "âŒ **é…ç½®ç¼ºå¤±**: è¯·åœ¨ `prod.yaml` ä¸­æ·»åŠ  `game_bot_username` é…ç½®é¡¹ã€‚")
        return

    progress_msg = await client.reply_to_admin(event, f"â³ `[{my_username}] ç§å¯†é›†ç«å¯åŠ¨`\næ­£åœ¨æ‰«æç½‘ç»œæŸ¥æ‰¾`{item_name}`...")
    client.pin_message(progress_msg)
    
    executor_id, _ = await trade_logic.find_best_executor(item_name, quantity, exclude_id=my_id)

    if not executor_id:
        await progress_msg.edit(f"âŒ **ä»»åŠ¡å¤±è´¥**: æœªåœ¨ç½‘ç»œä¸­æ‰¾åˆ°æ‹¥æœ‰è¶³å¤Ÿæ•°é‡`{item_name}`çš„å…¶ä»–åŠ©æ‰‹ã€‚")
        client.unpin_message(progress_msg)
        return

    await progress_msg.edit(f"âœ… `å·²å®šä½åŠ©æ‰‹` (ID: `...{executor_id[-4:]}`)\nâ³ æ­£åœ¨é€šè¿‡ Redis ä¸‹è¾¾ç§èŠä¸Šæ¶æŒ‡ä»¤...")
    
    session_id = f"pff_{my_id}_{int(asyncio.get_running_loop().time())}"
    sessions[session_id] = {"initiator_id": my_id, "executor_id": executor_id, "messages_to_delete": {"initiator": [], "executor": []}}

    task = {
        "task_type": "private_list_for_ff",
        "target_account_id": executor_id,
        "payload": { "session_id": session_id, "item_name": item_name, "item_quantity": quantity, "initiator_id": my_id }
    }
    await trade_logic.publish_task(task)
    await progress_msg.edit(f"âœ… `æŒ‡ä»¤å·²å‘é€`\næ­£åœ¨ç­‰å¾…åŠ©æ‰‹ `...{executor_id[-4:]}` åœ¨ç§èŠä¸­ä¸Šæ¶ç‰©å“...")
    client.unpin_message(progress_msg)

async def private_trade_redis_handler(app, my_id, data):
    client = app.client
    task_type = data.get("task_type")
    payload = data.get("payload", {})
    target_id = data.get("target_account_id")

    if my_id != target_id: return

    session_id = payload.get("session_id")

    # --- ä¸Šæ¶ä»»åŠ¡ (é€šç”¨) ---
    if task_type == "private_list_for_ff" or task_type == "private_list_for_trade":
        item_name = payload.get("item_name")
        quantity = payload.get("item_quantity")
        initiator_id = payload.get("initiator_id")
        
        # 'ç§èŠäº¤æ˜“'æ˜¯å¯¹æ–¹ä¸Šæ¶ï¼Œè‡ªå·±è´­ä¹°ï¼Œæ‰€ä»¥ä¸Šæ¶çš„æ˜¯çµçŸ³
        list_item_name = "çµçŸ³" if task_type == "private_list_for_trade" else item_name
        list_item_quantity = 1 if task_type == "private_list_for_trade" else quantity
        buy_item_name = item_name if task_type == "private_list_for_trade" else "çµçŸ³"
        buy_item_quantity = quantity if task_type == "private_list_for_trade" else 1

        format_and_log("TASK", "ç§å¯†äº¤æ˜“-ä¸Šæ¶", {'é˜¶æ®µ': 'æ”¶åˆ°ä»»åŠ¡'})
        sent_msgs, reply_msgs = [], []
        try:
            list_cmd = f".ä¸Šæ¶ {list_item_name}*{list_item_quantity} æ¢ {buy_item_name}*{buy_item_quantity}"
            sent_msg, reply_msg = await client.send_game_command_request_response(list_cmd, target_chat_id=settings.GAME_BOT_USERNAME)
            sent_msgs.append(sent_msg.id); reply_msgs.append(reply_msg.id)
            
            match = re.search(r"æŒ‚å•ID\D+(\d+)", reply_msg.raw_text)
            if "ä¸Šæ¶æˆåŠŸ" in reply_msg.raw_text and match:
                listing_id = match.group(1)
                
                # 'ç§å¯†é›†ç«'éœ€è¦ç«‹å³ä¸‹æ¶
                if task_type == "private_list_for_ff" and settings.TRADE_COORDINATION_CONFIG.get('focus_fire_auto_delist', True):
                    await asyncio.sleep(random.uniform(1, 2))
                    delist_sent = await client.send_game_command_fire_and_forget(f".ä¸‹æ¶ {listing_id}", target_chat_id=settings.GAME_BOT_USERNAME)
                    sent_msgs.append(delist_sent.id)

                response_task_type = "private_purchase_for_ff" if task_type == "private_list_for_ff" else "private_purchase_for_trade"
                response_task = {
                    "task_type": response_task_type,
                    "target_account_id": initiator_id,
                    "payload": {"session_id": session_id, "listing_id": listing_id, "executor_msgs": sent_msgs + reply_msgs}
                }
                await trade_logic.publish_task(response_task)
        except Exception as e:
            await client.send_admin_notification(f"âŒ `...{my_id[-4:]}` åœ¨ç§å¯†äº¤æ˜“ä¸Šæ¶æ—¶å¤±è´¥: {e}")

    # --- è´­ä¹°ä»»åŠ¡ (é€šç”¨) ---
    elif task_type == "private_purchase_for_ff" or task_type == "private_purchase_for_trade":
        listing_id = payload.get("listing_id")
        if session := sessions.get(session_id):
            session["messages_to_delete"]["executor"].extend(payload.get("executor_msgs", []))
            format_and_log("TASK", "ç§å¯†äº¤æ˜“-è´­ä¹°", {'é˜¶æ®µ': 'æ”¶åˆ°ä»»åŠ¡', 'æŒ‚å•ID': listing_id})
            try:
                sent_msg, reply_msg = await client.send_game_command_request_response(f".è´­ä¹° {listing_id}", target_chat_id=settings.GAME_BOT_USERNAME)
                session["messages_to_delete"]["initiator"].extend([sent_msg.id, reply_msg.id])

                if "äº¤æ˜“æˆåŠŸ" in reply_msg.text:
                    await client.send_admin_notification(f"âœ… **ç§å¯†äº¤æ˜“æˆåŠŸ** (æŒ‚å•ID: `{listing_id}`)\nâ³ æ­£åœ¨æ¸…ç†åŒæ–¹èŠå¤©è®°å½•...")
                    for user_type, msg_ids in session["messages_to_delete"].items():
                        cleanup_task = {"task_type": "private_cleanup", "target_account_id": session[f"{user_type}_id"], "payload": {"msg_ids": msg_ids}}
                        await trade_logic.publish_task(cleanup_task)
                else:
                    await client.send_admin_notification(f"âš ï¸ **ç§å¯†è´­ä¹°å¤±è´¥** (æŒ‚å•ID: `{listing_id}`)\nè¿”å›: `{reply_msg.text}`")
            except Exception as e:
                await client.send_admin_notification(f"âŒ åœ¨ç§å¯†è´­ä¹°`{listing_id}`æ—¶å¤±è´¥: {e}")
            finally:
                 if session_id in sessions: del sessions[session_id]

    # --- æ¸…ç†ä»»åŠ¡ ---
    elif task_type == "private_cleanup":
        msg_ids = payload.get("msg_ids", [])
        if msg_ids:
            await client.client.delete_messages(settings.GAME_BOT_USERNAME, msg_ids)
            format_and_log("TASK", "ç§èŠæ¸…ç†", {'çŠ¶æ€': 'æˆåŠŸ', 'æ•°é‡': len(msg_ids)})

def initialize(app):
    app.register_command("ç§èŠäº¤æ˜“", _cmd_private_trade, help_text="ğŸ” é€šè¿‡ç§èŠå®‰å…¨åœ°è½¬ç§»ç‰©å“ã€‚", category="é«˜çº§ååŒ", usage=HELP_TEXT_PRIVATE_TRADE)
    app.register_command("ç§ç«", _cmd_private_focus_fire, help_text="ğŸ”¥ é€šè¿‡ç§èŠå®‰å…¨åœ°é›†ç«ç‰©å“ã€‚", category="é«˜çº§ååŒ", usage=HELP_TEXT_PRIVATE_FOCUS_FIRE)

    # å°†æœ¬æ’ä»¶çš„å¤„ç†å™¨æ³¨å†Œåˆ°å…¨å±€
    app.private_trade_redis_handler = private_trade_redis_handler

