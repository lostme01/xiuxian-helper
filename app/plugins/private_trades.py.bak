# -*- coding: utf-8 -*-
import json
import re
import asyncio
import random
from telethon import events
from app.context import get_application
from .logic import trade_logic
from app.logger import format_and_log
from config import settings
from app.telegram_client import CommandTimeoutError

HELP_TEXT_PRIVATE_TRADE = """🔐 **私聊交易**
**说明**: 在私聊环境中，由当前账号发起，与指定助手完成一次安全的物品转移（对方上架，自己购买）。
**用法**: `,私聊交易 <@目标助手> <物品> <数量>`
**示例**: `,私聊交易 @MyHelperBot 凝血草 10`
"""

HELP_TEXT_PRIVATE_FOCUS_FIRE = """🔥 **私密集火**
**说明**: 与“集火”功能类似，但整个上架和购买过程都在与游戏Bot的私聊中进行，并在结束后自动清理双方的私聊记录。
**用法**: `,私火 <物品> <数量>`
**示例**: `,私火 凝血草 10`
"""

# 用于在内存中追踪当前任务的状态
sessions = {}

async def _cmd_private_trade(event, parts):
    app = get_application()
    client = app.client
    my_id = str(client.me.id)
    my_username = client.me.username or my_id

    if len(parts) < 4:
        await client.reply_to_admin(event, f"❌ 参数不足！\n\n{HELP_TEXT_PRIVATE_TRADE}")
        return

    target_username = parts[1].lstrip('@')
    item_name = parts[2]
    try:
        quantity = int(parts[3])
    except ValueError:
        await client.reply_to_admin(event, f"❌ 数量必须是数字！")
        return
        
    if not getattr(settings, 'GAME_BOT_USERNAME', None):
        await client.reply_to_admin(event, "❌ **配置缺失**: 请在 `prod.yaml` 中添加 `game_bot_username` 配置项。")
        return

    progress_msg = await client.reply_to_admin(event, f"⏳ `[{my_username}] 私聊交易启动`\n正在解析目标助手...")
    client.pin_message(progress_msg)
    
    try:
        target_entity = await client.client.get_entity(target_username)
        executor_id = str(target_entity.id)
    except (ValueError, TypeError):
        await progress_msg.edit(f"❌ **目标无效**: 无法找到用户`@{target_username}`。")
        client.unpin_message(progress_msg)
        return

    await progress_msg.edit(f"✅ `已定位助手` (@{target_username})\n⏳ 正在通过 Redis 下达上架指令...")
    
    session_id = f"ptrade_{my_id}_{int(asyncio.get_running_loop().time())}"
    sessions[session_id] = {"initiator_id": my_id, "executor_id": executor_id, "messages_to_delete": {"initiator": [], "executor": []}}

    task = {
        "task_type": "private_list_for_trade",
        "target_account_id": executor_id,
        "payload": { "session_id": session_id, "item_name": item_name, "item_quantity": quantity, "initiator_id": my_id }
    }
    await trade_logic.publish_task(task)
    await progress_msg.edit(f"✅ `指令已发送`\n正在等待 @{target_username} 在私聊中上架物品...")
    client.unpin_message(progress_msg)

async def _cmd_private_focus_fire(event, parts):
    app = get_application()
    client = app.client
    my_id = str(client.me.id)
    my_username = client.me.username or my_id

    if len(parts) < 3:
        await client.reply_to_admin(event, f"❌ 参数不足！\n\n{HELP_TEXT_PRIVATE_FOCUS_FIRE}")
        return

    item_name = " ".join(parts[1:-1])
    try:
        quantity = int(parts[-1])
    except (ValueError, IndexError):
        await client.reply_to_admin(event, f"❌ 参数格式错误！")
        return
        
    if not getattr(settings, 'GAME_BOT_USERNAME', None):
        await client.reply_to_admin(event, "❌ **配置缺失**: 请在 `prod.yaml` 中添加 `game_bot_username` 配置项。")
        return

    progress_msg = await client.reply_to_admin(event, f"⏳ `[{my_username}] 私密集火启动`\n正在扫描网络查找`{item_name}`...")
    client.pin_message(progress_msg)
    
    executor_id, _ = await trade_logic.find_best_executor(item_name, quantity, exclude_id=my_id)

    if not executor_id:
        await progress_msg.edit(f"❌ **任务失败**: 未在网络中找到拥有足够数量`{item_name}`的其他助手。")
        client.unpin_message(progress_msg)
        return

    await progress_msg.edit(f"✅ `已定位助手` (ID: `...{executor_id[-4:]}`)\n⏳ 正在通过 Redis 下达私聊上架指令...")
    
    session_id = f"pff_{my_id}_{int(asyncio.get_running_loop().time())}"
    sessions[session_id] = {"initiator_id": my_id, "executor_id": executor_id, "messages_to_delete": {"initiator": [], "executor": []}}

    task = {
        "task_type": "private_list_for_ff",
        "target_account_id": executor_id,
        "payload": { "session_id": session_id, "item_name": item_name, "item_quantity": quantity, "initiator_id": my_id }
    }
    await trade_logic.publish_task(task)
    await progress_msg.edit(f"✅ `指令已发送`\n正在等待助手 `...{executor_id[-4:]}` 在私聊中上架物品...")
    client.unpin_message(progress_msg)

async def private_trade_redis_handler(app, my_id, data):
    client = app.client
    task_type = data.get("task_type")
    payload = data.get("payload", {})
    target_id = data.get("target_account_id")

    if my_id != target_id: return

    session_id = payload.get("session_id")

    # --- 上架任务 (通用) ---
    if task_type == "private_list_for_ff" or task_type == "private_list_for_trade":
        item_name = payload.get("item_name")
        quantity = payload.get("item_quantity")
        initiator_id = payload.get("initiator_id")
        
        # '私聊交易'是对方上架，自己购买，所以上架的是灵石
        list_item_name = "灵石" if task_type == "private_list_for_trade" else item_name
        list_item_quantity = 1 if task_type == "private_list_for_trade" else quantity
        buy_item_name = item_name if task_type == "private_list_for_trade" else "灵石"
        buy_item_quantity = quantity if task_type == "private_list_for_trade" else 1

        format_and_log("TASK", "私密交易-上架", {'阶段': '收到任务'})
        sent_msgs, reply_msgs = [], []
        try:
            list_cmd = f".上架 {list_item_name}*{list_item_quantity} 换 {buy_item_name}*{buy_item_quantity}"
            sent_msg, reply_msg = await client.send_game_command_request_response(list_cmd, target_chat_id=settings.GAME_BOT_USERNAME)
            sent_msgs.append(sent_msg.id); reply_msgs.append(reply_msg.id)
            
            match = re.search(r"挂单ID\D+(\d+)", reply_msg.raw_text)
            if "上架成功" in reply_msg.raw_text and match:
                listing_id = match.group(1)
                
                # '私密集火'需要立即下架
                if task_type == "private_list_for_ff" and settings.TRADE_COORDINATION_CONFIG.get('focus_fire_auto_delist', True):
                    await asyncio.sleep(random.uniform(1, 2))
                    delist_sent = await client.send_game_command_fire_and_forget(f".下架 {listing_id}", target_chat_id=settings.GAME_BOT_USERNAME)
                    sent_msgs.append(delist_sent.id)

                response_task_type = "private_purchase_for_ff" if task_type == "private_list_for_ff" else "private_purchase_for_trade"
                response_task = {
                    "task_type": response_task_type,
                    "target_account_id": initiator_id,
                    "payload": {"session_id": session_id, "listing_id": listing_id, "executor_msgs": sent_msgs + reply_msgs}
                }
                await trade_logic.publish_task(response_task)
        except Exception as e:
            await client.send_admin_notification(f"❌ `...{my_id[-4:]}` 在私密交易上架时失败: {e}")

    # --- 购买任务 (通用) ---
    elif task_type == "private_purchase_for_ff" or task_type == "private_purchase_for_trade":
        listing_id = payload.get("listing_id")
        if session := sessions.get(session_id):
            session["messages_to_delete"]["executor"].extend(payload.get("executor_msgs", []))
            format_and_log("TASK", "私密交易-购买", {'阶段': '收到任务', '挂单ID': listing_id})
            try:
                sent_msg, reply_msg = await client.send_game_command_request_response(f".购买 {listing_id}", target_chat_id=settings.GAME_BOT_USERNAME)
                session["messages_to_delete"]["initiator"].extend([sent_msg.id, reply_msg.id])

                if "交易成功" in reply_msg.text:
                    await client.send_admin_notification(f"✅ **私密交易成功** (挂单ID: `{listing_id}`)\n⏳ 正在清理双方聊天记录...")
                    for user_type, msg_ids in session["messages_to_delete"].items():
                        cleanup_task = {"task_type": "private_cleanup", "target_account_id": session[f"{user_type}_id"], "payload": {"msg_ids": msg_ids}}
                        await trade_logic.publish_task(cleanup_task)
                else:
                    await client.send_admin_notification(f"⚠️ **私密购买失败** (挂单ID: `{listing_id}`)\n返回: `{reply_msg.text}`")
            except Exception as e:
                await client.send_admin_notification(f"❌ 在私密购买`{listing_id}`时失败: {e}")
            finally:
                 if session_id in sessions: del sessions[session_id]

    # --- 清理任务 ---
    elif task_type == "private_cleanup":
        msg_ids = payload.get("msg_ids", [])
        if msg_ids:
            await client.client.delete_messages(settings.GAME_BOT_USERNAME, msg_ids)
            format_and_log("TASK", "私聊清理", {'状态': '成功', '数量': len(msg_ids)})

def initialize(app):
    app.register_command("私聊交易", _cmd_private_trade, help_text="🔐 通过私聊安全地转移物品。", category="高级协同", usage=HELP_TEXT_PRIVATE_TRADE)
    app.register_command("私火", _cmd_private_focus_fire, help_text="🔥 通过私聊安全地集火物品。", category="高级协同", usage=HELP_TEXT_PRIVATE_FOCUS_FIRE)

    # 将本插件的处理器注册到全局
    app.private_trade_redis_handler = private_trade_redis_handler

