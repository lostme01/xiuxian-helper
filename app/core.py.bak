# -*- coding: utf-8 -*-
import asyncio
import logging
import logging.handlers
import pytz
import os
import sys
from config import settings
from app.task_scheduler import scheduler, shutdown
from app.telegram_client import TelegramClient
from app.redis_client import initialize_redis
from app.plugins import (
    common_tasks, huangfeng_valley, taiyi_sect, 
    learning_tasks, exam_solver, tianji_exam_solver
)
from app.logger import format_and_log
# --- 核心修改：导入新的指令初始化函数 ---
from app.commands import initialize_all_commands
from app.context import set_application

class Application:
    def __init__(self):
        self.client: TelegramClient = None
        self.redis_db = None
        self.startup_checks = []
        set_application(self)
        self.setup_logging()
        format_and_log("SYSTEM", "系统初始化", {'状态': '应用开始初始化...'})
        self.redis_db = initialize_redis()
        self.client = TelegramClient()
        self.load_plugins_and_commands()
        format_and_log("SYSTEM", "系统初始化", {'状态': '所有模块加载完毕。'})

    def setup_logging(self):
        log_format = '%(message)s'
        log_level = logging.INFO
        root_logger = logging.getLogger()
        if root_logger.hasHandlers(): root_logger.handlers.clear()
        formatter = logging.Formatter(fmt=log_format)
        stream_handler = logging.StreamHandler(sys.stdout)
        stream_handler.setFormatter(formatter)
        root_logger.addHandler(stream_handler)
        root_logger.setLevel(log_level)
        logging.getLogger('apscheduler').setLevel(logging.ERROR)
        logging.getLogger('telethon').setLevel(logging.WARNING)
        logging.getLogger('asyncio').setLevel(logging.WARNING)
        raw_logger = logging.getLogger('raw_messages')
        raw_logger.setLevel(logging.INFO)
        raw_logger.propagate = False
        if raw_logger.hasHandlers(): raw_logger.handlers.clear()
        raw_handler = logging.handlers.RotatingFileHandler(
            settings.RAW_LOG_FILE, maxBytes=settings.LOG_ROTATION_CONFIG['max_bytes'], 
            backupCount=settings.LOG_ROTATION_CONFIG['backup_count'], encoding='utf-8')
        raw_formatter = logging.Formatter('%(asctime)s\n%(message)s\n' + '-'*50, datefmt='%Y-%m-%d %H:%M:%S')
        raw_handler.setFormatter(raw_formatter)
        raw_logger.addHandler(raw_handler)
        
    def load_plugins_and_commands(self):
        # 1. 加载后台任务插件
        common_checks = common_tasks.initialize_tasks()
        if common_checks: self.startup_checks.extend(common_checks)
        learning_checks = learning_tasks.initialize_tasks()
        if learning_checks: self.startup_checks.extend(learning_checks)
        if settings.SECT_NAME == '黄枫谷':
            sect_checks = huangfeng_valley.initialize_tasks()
            if sect_checks: self.startup_checks.extend(sect_checks)
        elif settings.SECT_NAME == '太一门':
            sect_checks = taiyi_sect.initialize_tasks()
            if sect_checks: self.startup_checks.extend(sect_checks)
        
        # 2. 加载答题插件
        if self.redis_db:
            exam_solver.initialize_plugin(self.client, self.redis_db)
            tianji_exam_solver.initialize_plugin(self.client, self.redis_db)

        # 3. 核心修改：加载所有管理员指令
        initialize_all_commands(self.client)

    async def run(self):
        try:
            scheduler.start()
            await self.client.start()
            await self.client.warm_up_entity_cache()
            
            format_and_log("SYSTEM", "核心服务", {'状态': '正在执行启动后任务检查...'})
            if self.startup_checks:
                await asyncio.gather(*(check() for check in self.startup_checks))
            
            await self.client.send_admin_notification("✅ **助手已成功启动并在线**")
            format_and_log("SYSTEM", "核心服务", {'状态': '应用已准备就绪。'})
            await self.client.run_until_disconnected()
        except Exception:
            logging.critical("应用启动或运行过程中发生严重错误:", exc_info=True)
        finally:
            if self.client and self.client.is_connected():
                await self.client.disconnect()
            shutdown()
            format_and_log("SYSTEM", "核心服务", {'状态': '应用已关闭。'})
